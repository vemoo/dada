// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use id_tree::Tree;

use miette::{miette, Result};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

use crate::grammar::Grammar;
use std::path::Path;

///
/// The `GrammarTrait` trait is automatically generated for the
/// given grammar.
/// All functions have default implementations.
///
pub trait GrammarTrait {
    ///
    /// Implement this method if you need the provided information
    ///
    fn init(&mut self, _file_name: &Path) {}

    /// Semantic action for production 0:
    ///
    /// Items: ItemsList /* Vec */;
    ///
    fn items_0(
        &mut self,
        _items_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// ItemsList: Item ItemsList; // Vec<T>::Push
    ///
    fn items_list_0(
        &mut self,
        _item_0: &ParseTreeStackEntry,
        _items_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// ItemsList: ; // Vec<T>::New
    ///
    fn items_list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// Item: Class;
    ///
    fn item_0(
        &mut self,
        _class_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// Item: Function;
    ///
    fn item_1(
        &mut self,
        _function_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// Class: "class" Identifier FieldList;
    ///
    fn class_0(
        &mut self,
        _class_0: &ParseTreeStackEntry,
        _identifier_1: &ParseTreeStackEntry,
        _field_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// FieldList: "\(" FieldListSuffix;
    ///
    fn field_list_0(
        &mut self,
        _l_paren_0: &ParseTreeStackEntry,
        _field_list_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// FieldListSuffix: "\)";
    ///
    fn field_list_suffix_0(
        &mut self,
        _r_paren_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// FieldListSuffix: Field FieldListList /* Vec */ "\)";
    ///
    fn field_list_suffix_1(
        &mut self,
        _field_0: &ParseTreeStackEntry,
        _field_list_list_1: &ParseTreeStackEntry,
        _r_paren_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// FieldListList: "," Field FieldListList; // Vec<T>::Push
    ///
    fn field_list_list_0(
        &mut self,
        _comma_0: &ParseTreeStackEntry,
        _field_1: &ParseTreeStackEntry,
        _field_list_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// FieldListList: Field FieldListList; // Vec<T>::Push
    ///
    fn field_list_list_1(
        &mut self,
        _field_0: &ParseTreeStackEntry,
        _field_list_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// FieldListList: ; // Vec<T>::New
    ///
    fn field_list_list_2(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// Field: StorageMode Identifier;
    ///
    fn field_0(
        &mut self,
        _storage_mode_0: &ParseTreeStackEntry,
        _identifier_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// Field: Identifier;
    ///
    fn field_1(
        &mut self,
        _identifier_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// StorageMode: "atomic";
    ///
    fn storage_mode_0(
        &mut self,
        _storage_mode_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// Function: Effect "fn" Identifier ArgumentList FunctionBody;
    ///
    fn function_0(
        &mut self,
        _effect_0: &ParseTreeStackEntry,
        _fn_1: &ParseTreeStackEntry,
        _identifier_2: &ParseTreeStackEntry,
        _argument_list_3: &ParseTreeStackEntry,
        _function_body_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// Function: "fn" Identifier ArgumentList FunctionBody;
    ///
    fn function_1(
        &mut self,
        _fn_0: &ParseTreeStackEntry,
        _identifier_1: &ParseTreeStackEntry,
        _argument_list_2: &ParseTreeStackEntry,
        _function_body_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// Effect: "async";
    ///
    fn effect_0(
        &mut self,
        _effect_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// ArgumentList: "\(" ArgumentListSuffix;
    ///
    fn argument_list_0(
        &mut self,
        _l_paren_0: &ParseTreeStackEntry,
        _argument_list_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// ArgumentListSuffix: "\)";
    ///
    fn argument_list_suffix_0(
        &mut self,
        _r_paren_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// ArgumentListSuffix: Identifier ArgumentListList /* Vec */ "\)";
    ///
    fn argument_list_suffix_1(
        &mut self,
        _identifier_0: &ParseTreeStackEntry,
        _argument_list_list_1: &ParseTreeStackEntry,
        _r_paren_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// ArgumentListList: "," Identifier ArgumentListList; // Vec<T>::Push
    ///
    fn argument_list_list_0(
        &mut self,
        _comma_0: &ParseTreeStackEntry,
        _identifier_1: &ParseTreeStackEntry,
        _argument_list_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// ArgumentListList: ; // Vec<T>::New
    ///
    fn argument_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// FunctionBody: "\{" FunctionBodyList /* Vec */ MaybeReturnWithoutExpr "\}";
    ///
    fn function_body_0(
        &mut self,
        _l_brace_0: &ParseTreeStackEntry,
        _function_body_list_1: &ParseTreeStackEntry,
        _maybe_return_without_expr_2: &ParseTreeStackEntry,
        _r_brace_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// FunctionBodyList: Expr FunctionBodyList; // Vec<T>::Push
    ///
    fn function_body_list_0(
        &mut self,
        _expr_0: &ParseTreeStackEntry,
        _function_body_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// FunctionBodyList: ; // Vec<T>::New
    ///
    fn function_body_list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// Expr: LocalVariable;
    ///
    fn expr_0(
        &mut self,
        _local_variable_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// Expr: ReturnWithExpr;
    ///
    fn expr_1(
        &mut self,
        _return_with_expr_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// Expr: Expr5;
    ///
    fn expr_2(
        &mut self,
        _expr5_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// ReturnWithExpr: "return" Expr;
    ///
    fn return_with_expr_0(
        &mut self,
        _return_without_expr_0: &ParseTreeStackEntry,
        _expr_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// ReturnWithoutExpr: "return";
    ///
    fn return_without_expr_0(
        &mut self,
        _return_without_expr_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// MaybeReturnWithoutExpr: ReturnWithoutExpr;
    ///
    fn maybe_return_without_expr_0(
        &mut self,
        _return_without_expr_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// MaybeReturnWithoutExpr: ;
    ///
    fn maybe_return_without_expr_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// Expr5: Expr4 Expr5List /* Vec */;
    ///
    fn expr5_0(
        &mut self,
        _expr4_0: &ParseTreeStackEntry,
        _expr5_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// Expr5List: Expr5ListGroup Expr4 Expr5List; // Vec<T>::Push
    ///
    fn expr5_list_0(
        &mut self,
        _expr5_list_group_0: &ParseTreeStackEntry,
        _expr4_1: &ParseTreeStackEntry,
        _expr5_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// Expr5ListGroup: "\+=";
    ///
    fn expr5_list_group_0(
        &mut self,
        _plus_equ_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// Expr5ListGroup: "-=";
    ///
    fn expr5_list_group_1(
        &mut self,
        _minus_equ_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// Expr5ListGroup: "/=";
    ///
    fn expr5_list_group_2(
        &mut self,
        _slash_equ_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// Expr5ListGroup: "\*=";
    ///
    fn expr5_list_group_3(
        &mut self,
        _star_equ_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// Expr5ListGroup: ":=";
    ///
    fn expr5_list_group_4(
        &mut self,
        _colon_equ_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// Expr5List: ; // Vec<T>::New
    ///
    fn expr5_list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// Expr4: Expr3 Expr4List /* Vec */;
    ///
    fn expr4_0(
        &mut self,
        _expr3_0: &ParseTreeStackEntry,
        _expr4_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// Expr4List: Expr4ListGroup Expr3 Expr4List; // Vec<T>::Push
    ///
    fn expr4_list_0(
        &mut self,
        _expr4_list_group_0: &ParseTreeStackEntry,
        _expr3_1: &ParseTreeStackEntry,
        _expr4_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// Expr4ListGroup: "==";
    ///
    fn expr4_list_group_0(
        &mut self,
        _equ_equ_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// Expr4ListGroup: "<";
    ///
    fn expr4_list_group_1(
        &mut self,
        _l_t_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// Expr4ListGroup: ">";
    ///
    fn expr4_list_group_2(
        &mut self,
        _g_t_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// Expr4List: ; // Vec<T>::New
    ///
    fn expr4_list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// Expr3: Expr2 Expr3List /* Vec */;
    ///
    fn expr3_0(
        &mut self,
        _expr2_0: &ParseTreeStackEntry,
        _expr3_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// Expr3List: Expr3ListGroup Expr2 Expr3List; // Vec<T>::Push
    ///
    fn expr3_list_0(
        &mut self,
        _expr3_list_group_0: &ParseTreeStackEntry,
        _expr2_1: &ParseTreeStackEntry,
        _expr3_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// Expr3ListGroup: "\+";
    ///
    fn expr3_list_group_0(
        &mut self,
        _plus_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// Expr3ListGroup: "-";
    ///
    fn expr3_list_group_1(
        &mut self,
        _minus_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// Expr3List: ; // Vec<T>::New
    ///
    fn expr3_list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// Expr2: Expr1 Expr2List /* Vec */;
    ///
    fn expr2_0(
        &mut self,
        _expr1_0: &ParseTreeStackEntry,
        _expr2_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// Expr2List: Expr2ListGroup Expr1 Expr2List; // Vec<T>::Push
    ///
    fn expr2_list_0(
        &mut self,
        _expr2_list_group_0: &ParseTreeStackEntry,
        _expr1_1: &ParseTreeStackEntry,
        _expr2_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// Expr2ListGroup: "/";
    ///
    fn expr2_list_group_0(
        &mut self,
        _slash_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// Expr2ListGroup: "\*";
    ///
    fn expr2_list_group_1(
        &mut self,
        _star_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// Expr2List: ; // Vec<T>::New
    ///
    fn expr2_list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// Expr1: Expr0 Expr1List /* Vec */;
    ///
    fn expr1_0(
        &mut self,
        _expr0_0: &ParseTreeStackEntry,
        _expr1_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// Expr1List: Expr1ListGroup Expr1List; // Vec<T>::Push
    ///
    fn expr1_list_0(
        &mut self,
        _expr1_list_group_0: &ParseTreeStackEntry,
        _expr1_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// Expr1ListGroup: DotExpr;
    ///
    fn expr1_list_group_0(
        &mut self,
        _dot_expr_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// Expr1ListGroup: CallArgumentList;
    ///
    fn expr1_list_group_1(
        &mut self,
        _call_argument_list_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// Expr1List: ; // Vec<T>::New
    ///
    fn expr1_list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// DotExpr: "\." DotSuffix;
    ///
    fn dot_expr_0(
        &mut self,
        _dot_0: &ParseTreeStackEntry,
        _dot_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// DotSuffix: "await";
    ///
    fn dot_suffix_0(
        &mut self,
        _await_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// DotSuffix: "share";
    ///
    fn dot_suffix_1(
        &mut self,
        _share_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// DotSuffix: "give";
    ///
    fn dot_suffix_2(
        &mut self,
        _give_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// DotSuffix: "lease";
    ///
    fn dot_suffix_3(
        &mut self,
        _lease_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// DotSuffix: Identifier;
    ///
    fn dot_suffix_4(
        &mut self,
        _identifier_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// CallArgumentList: "\(" CallArgumentListSuffix;
    ///
    fn call_argument_list_0(
        &mut self,
        _l_paren_0: &ParseTreeStackEntry,
        _call_argument_list_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// CallArgumentListSuffix: "\)";
    ///
    fn call_argument_list_suffix_0(
        &mut self,
        _r_paren_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// CallArgumentListSuffix: CallArgument CallArgumentListList /* Vec */ MaybeTrailingComma "\)";
    ///
    fn call_argument_list_suffix_1(
        &mut self,
        _call_argument_0: &ParseTreeStackEntry,
        _call_argument_list_list_1: &ParseTreeStackEntry,
        _maybe_trailing_comma_2: &ParseTreeStackEntry,
        _r_paren_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// CallArgumentListList: "," CallArgument CallArgumentListList; // Vec<T>::Push
    ///
    fn call_argument_list_list_0(
        &mut self,
        _comma_0: &ParseTreeStackEntry,
        _call_argument_1: &ParseTreeStackEntry,
        _call_argument_list_list_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// CallArgumentListList: ; // Vec<T>::New
    ///
    fn call_argument_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// MaybeTrailingComma: ",";
    ///
    fn maybe_trailing_comma_0(
        &mut self,
        _comma_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// MaybeTrailingComma: ;
    ///
    fn maybe_trailing_comma_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// CallArgument: Identifier ":" Expr;
    ///
    fn call_argument_0(
        &mut self,
        _identifier_0: &ParseTreeStackEntry,
        _colon_1: &ParseTreeStackEntry,
        _expr_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// CallArgument: Expr;
    ///
    fn call_argument_1(
        &mut self,
        _expr_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// Expr0: Identifier;
    ///
    fn expr0_0(
        &mut self,
        _identifier_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// Expr0: BooleanLiteral;
    ///
    fn expr0_1(
        &mut self,
        _boolean_literal_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// Expr0: FloatLiteral;
    ///
    fn expr0_2(
        &mut self,
        _float_literal_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// Expr0: IntegerLiteral;
    ///
    fn expr0_3(
        &mut self,
        _integer_literal_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// Expr0: StringLiteral;
    ///
    fn expr0_4(
        &mut self,
        _string_literal_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// Expr0: BlockExpr;
    ///
    fn expr0_5(
        &mut self,
        _block_expr_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// Expr0: AtomicBlock;
    ///
    fn expr0_6(
        &mut self,
        _atomic_block_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// Expr0: IfExpr;
    ///
    fn expr0_7(
        &mut self,
        _if_expr_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// Expr0: Loop;
    ///
    fn expr0_8(
        &mut self,
        _loop_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// Expr0: While;
    ///
    fn expr0_9(
        &mut self,
        _while_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// Expr0: Tuple;
    ///
    fn expr0_10(
        &mut self,
        _tuple_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// BooleanLiteral: "true";
    ///
    fn boolean_literal_0(
        &mut self,
        _true_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// BooleanLiteral: "false";
    ///
    fn boolean_literal_1(
        &mut self,
        _false_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// Identifier: "[a-z|A-Z_][a-z|A-Z|0-9_]*";
    ///
    fn identifier_0(
        &mut self,
        _identifier_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// FloatLiteral: "[0-9][0-9_]*\.[0-9][0-9_]*";
    ///
    fn float_literal_0(
        &mut self,
        _float_literal_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// IntegerLiteral: "[0-9][0-9_]*";
    ///
    fn integer_literal_0(
        &mut self,
        _integer_literal_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// StringLiteral: "\u{0022}(?s:[^\u{0022}]*)\u{0022}";
    ///
    fn string_literal_0(
        &mut self,
        _string_literal_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// BlockExpr: "\{" BlockExprList /* Vec */ MaybeReturnWithoutExpr "\}";
    ///
    fn block_expr_0(
        &mut self,
        _l_brace_0: &ParseTreeStackEntry,
        _block_expr_list_1: &ParseTreeStackEntry,
        _maybe_return_without_expr_2: &ParseTreeStackEntry,
        _r_brace_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// BlockExprList: Expr BlockExprList; // Vec<T>::Push
    ///
    fn block_expr_list_0(
        &mut self,
        _expr_0: &ParseTreeStackEntry,
        _block_expr_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// BlockExprList: ; // Vec<T>::New
    ///
    fn block_expr_list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// AtomicBlock: "atomic" BlockExpr;
    ///
    fn atomic_block_0(
        &mut self,
        _storage_mode_0: &ParseTreeStackEntry,
        _block_expr_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// IfExpr: "if" Condition "\{" IfExprList /* Vec */ IfExprGroup;
    ///
    fn if_expr_0(
        &mut self,
        _if_0: &ParseTreeStackEntry,
        _condition_1: &ParseTreeStackEntry,
        _l_brace_2: &ParseTreeStackEntry,
        _if_expr_list_3: &ParseTreeStackEntry,
        _if_expr_group_4: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// IfExprGroup: "\}" IfExprGroupSuffix;
    ///
    fn if_expr_group_0(
        &mut self,
        _r_brace_0: &ParseTreeStackEntry,
        _if_expr_group_suffix_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// IfExprGroupSuffix: ;
    ///
    fn if_expr_group_suffix_0(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// IfExprGroupSuffix: "else" "\{" IfExprGroupList /* Vec */ "\}";
    ///
    fn if_expr_group_suffix_1(
        &mut self,
        _else_0: &ParseTreeStackEntry,
        _l_brace_1: &ParseTreeStackEntry,
        _if_expr_group_list_2: &ParseTreeStackEntry,
        _r_brace_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// IfExprGroupList: Expr IfExprGroupList; // Vec<T>::Push
    ///
    fn if_expr_group_list_0(
        &mut self,
        _expr_0: &ParseTreeStackEntry,
        _if_expr_group_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// IfExprGroupList: ; // Vec<T>::New
    ///
    fn if_expr_group_list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// IfExprList: Expr IfExprList; // Vec<T>::Push
    ///
    fn if_expr_list_0(
        &mut self,
        _expr_0: &ParseTreeStackEntry,
        _if_expr_list_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// IfExprList: ; // Vec<T>::New
    ///
    fn if_expr_list_1(&mut self, _parse_tree: &Tree<ParseTreeType>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// Condition: Expr;
    ///
    fn condition_0(
        &mut self,
        _expr_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// Loop: "loop" BlockExpr;
    ///
    fn loop_0(
        &mut self,
        _loop_0: &ParseTreeStackEntry,
        _block_expr_1: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// While: "while" Condition BlockExpr;
    ///
    fn while_0(
        &mut self,
        _while_0: &ParseTreeStackEntry,
        _condition_1: &ParseTreeStackEntry,
        _block_expr_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// Tuple: "tuple";
    ///
    fn tuple_0(
        &mut self,
        _tuple_0: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// LocalVariable: StorageMode Identifier "=" Expr;
    ///
    fn local_variable_0(
        &mut self,
        _storage_mode_0: &ParseTreeStackEntry,
        _identifier_1: &ParseTreeStackEntry,
        _equ_2: &ParseTreeStackEntry,
        _expr_3: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// LocalVariable: Identifier "=" Expr;
    ///
    fn local_variable_1(
        &mut self,
        _identifier_0: &ParseTreeStackEntry,
        _equ_1: &ParseTreeStackEntry,
        _expr_2: &ParseTreeStackEntry,
        _parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        Ok(())
    }
}

impl UserActionsTrait<'_> for Grammar {
    ///
    /// Initialize the user with additional information.
    /// This function is called by the parser before parsing starts.
    /// It is used to transport necessary data from parser to user.
    ///
    fn init(&mut self, _file_name: &Path) {}

    ///
    /// This function is implemented automatically for the user's item Grammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry],
        parse_tree: &Tree<ParseTreeType>,
    ) -> Result<()> {
        match prod_num {
            0 => self.items_0(&children[0], parse_tree),
            1 => self.items_list_0(&children[0], &children[1], parse_tree),
            2 => self.items_list_1(parse_tree),
            3 => self.item_0(&children[0], parse_tree),
            4 => self.item_1(&children[0], parse_tree),
            5 => self.class_0(&children[0], &children[1], &children[2], parse_tree),
            6 => self.field_list_0(&children[0], &children[1], parse_tree),
            7 => self.field_list_suffix_0(&children[0], parse_tree),
            8 => self.field_list_suffix_1(&children[0], &children[1], &children[2], parse_tree),
            9 => self.field_list_list_0(&children[0], &children[1], &children[2], parse_tree),
            10 => self.field_list_list_1(&children[0], &children[1], parse_tree),
            11 => self.field_list_list_2(parse_tree),
            12 => self.field_0(&children[0], &children[1], parse_tree),
            13 => self.field_1(&children[0], parse_tree),
            14 => self.storage_mode_0(&children[0], parse_tree),
            15 => self.function_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            16 => self.function_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            17 => self.effect_0(&children[0], parse_tree),
            18 => self.argument_list_0(&children[0], &children[1], parse_tree),
            19 => self.argument_list_suffix_0(&children[0], parse_tree),
            20 => self.argument_list_suffix_1(&children[0], &children[1], &children[2], parse_tree),
            21 => self.argument_list_list_0(&children[0], &children[1], &children[2], parse_tree),
            22 => self.argument_list_list_1(parse_tree),
            23 => self.function_body_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            24 => self.function_body_list_0(&children[0], &children[1], parse_tree),
            25 => self.function_body_list_1(parse_tree),
            26 => self.expr_0(&children[0], parse_tree),
            27 => self.expr_1(&children[0], parse_tree),
            28 => self.expr_2(&children[0], parse_tree),
            29 => self.return_with_expr_0(&children[0], &children[1], parse_tree),
            30 => self.return_without_expr_0(&children[0], parse_tree),
            31 => self.maybe_return_without_expr_0(&children[0], parse_tree),
            32 => self.maybe_return_without_expr_1(parse_tree),
            33 => self.expr5_0(&children[0], &children[1], parse_tree),
            34 => self.expr5_list_0(&children[0], &children[1], &children[2], parse_tree),
            35 => self.expr5_list_group_0(&children[0], parse_tree),
            36 => self.expr5_list_group_1(&children[0], parse_tree),
            37 => self.expr5_list_group_2(&children[0], parse_tree),
            38 => self.expr5_list_group_3(&children[0], parse_tree),
            39 => self.expr5_list_group_4(&children[0], parse_tree),
            40 => self.expr5_list_1(parse_tree),
            41 => self.expr4_0(&children[0], &children[1], parse_tree),
            42 => self.expr4_list_0(&children[0], &children[1], &children[2], parse_tree),
            43 => self.expr4_list_group_0(&children[0], parse_tree),
            44 => self.expr4_list_group_1(&children[0], parse_tree),
            45 => self.expr4_list_group_2(&children[0], parse_tree),
            46 => self.expr4_list_1(parse_tree),
            47 => self.expr3_0(&children[0], &children[1], parse_tree),
            48 => self.expr3_list_0(&children[0], &children[1], &children[2], parse_tree),
            49 => self.expr3_list_group_0(&children[0], parse_tree),
            50 => self.expr3_list_group_1(&children[0], parse_tree),
            51 => self.expr3_list_1(parse_tree),
            52 => self.expr2_0(&children[0], &children[1], parse_tree),
            53 => self.expr2_list_0(&children[0], &children[1], &children[2], parse_tree),
            54 => self.expr2_list_group_0(&children[0], parse_tree),
            55 => self.expr2_list_group_1(&children[0], parse_tree),
            56 => self.expr2_list_1(parse_tree),
            57 => self.expr1_0(&children[0], &children[1], parse_tree),
            58 => self.expr1_list_0(&children[0], &children[1], parse_tree),
            59 => self.expr1_list_group_0(&children[0], parse_tree),
            60 => self.expr1_list_group_1(&children[0], parse_tree),
            61 => self.expr1_list_1(parse_tree),
            62 => self.dot_expr_0(&children[0], &children[1], parse_tree),
            63 => self.dot_suffix_0(&children[0], parse_tree),
            64 => self.dot_suffix_1(&children[0], parse_tree),
            65 => self.dot_suffix_2(&children[0], parse_tree),
            66 => self.dot_suffix_3(&children[0], parse_tree),
            67 => self.dot_suffix_4(&children[0], parse_tree),
            68 => self.call_argument_list_0(&children[0], &children[1], parse_tree),
            69 => self.call_argument_list_suffix_0(&children[0], parse_tree),
            70 => self.call_argument_list_suffix_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            71 => {
                self.call_argument_list_list_0(&children[0], &children[1], &children[2], parse_tree)
            }
            72 => self.call_argument_list_list_1(parse_tree),
            73 => self.maybe_trailing_comma_0(&children[0], parse_tree),
            74 => self.maybe_trailing_comma_1(parse_tree),
            75 => self.call_argument_0(&children[0], &children[1], &children[2], parse_tree),
            76 => self.call_argument_1(&children[0], parse_tree),
            77 => self.expr0_0(&children[0], parse_tree),
            78 => self.expr0_1(&children[0], parse_tree),
            79 => self.expr0_2(&children[0], parse_tree),
            80 => self.expr0_3(&children[0], parse_tree),
            81 => self.expr0_4(&children[0], parse_tree),
            82 => self.expr0_5(&children[0], parse_tree),
            83 => self.expr0_6(&children[0], parse_tree),
            84 => self.expr0_7(&children[0], parse_tree),
            85 => self.expr0_8(&children[0], parse_tree),
            86 => self.expr0_9(&children[0], parse_tree),
            87 => self.expr0_10(&children[0], parse_tree),
            88 => self.boolean_literal_0(&children[0], parse_tree),
            89 => self.boolean_literal_1(&children[0], parse_tree),
            90 => self.identifier_0(&children[0], parse_tree),
            91 => self.float_literal_0(&children[0], parse_tree),
            92 => self.integer_literal_0(&children[0], parse_tree),
            93 => self.string_literal_0(&children[0], parse_tree),
            94 => self.block_expr_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            95 => self.block_expr_list_0(&children[0], &children[1], parse_tree),
            96 => self.block_expr_list_1(parse_tree),
            97 => self.atomic_block_0(&children[0], &children[1], parse_tree),
            98 => self.if_expr_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            99 => self.if_expr_group_0(&children[0], &children[1], parse_tree),
            100 => self.if_expr_group_suffix_0(parse_tree),
            101 => self.if_expr_group_suffix_1(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            102 => self.if_expr_group_list_0(&children[0], &children[1], parse_tree),
            103 => self.if_expr_group_list_1(parse_tree),
            104 => self.if_expr_list_0(&children[0], &children[1], parse_tree),
            105 => self.if_expr_list_1(parse_tree),
            106 => self.condition_0(&children[0], parse_tree),
            107 => self.loop_0(&children[0], &children[1], parse_tree),
            108 => self.while_0(&children[0], &children[1], &children[2], parse_tree),
            109 => self.tuple_0(&children[0], parse_tree),
            110 => self.local_variable_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            111 => self.local_variable_1(&children[0], &children[1], &children[2], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
