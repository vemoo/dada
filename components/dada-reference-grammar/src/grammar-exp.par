%start Items
%line_comment "#"

%%

/*   0 */ Items: ItemsList /* Vec */;
/*   1 */ ItemsList: Item ItemsList; // Vec<T>::Push
/*   2 */ ItemsList: ; // Vec<T>::New
/*   3 */ Item: Class;
/*   4 */ Item: Function;
/*   5 */ Class: "class" Identifier FieldList;
/*   6 */ Sep: ",";
/*   7 */ Sep: "\n" SepList /* Vec */;
/*   8 */ SepList: "\n" SepList; // Vec<T>::Push
/*   9 */ SepList: ; // Vec<T>::New
/*  10 */ MaybeTrailingComma: MaybeTrailingCommaOpt /* Option */;
/*  11 */ MaybeTrailingCommaOpt: ","; // Option<T>::Some
/*  12 */ MaybeTrailingCommaOpt: ; // Option<T>::None
/*  13 */ FieldList: "\(" FieldListSuffix;
/*  14 */ FieldListSuffix: "\)";
/*  15 */ FieldListSuffix: Field FieldListList /* Vec */ MaybeTrailingComma "\)";
/*  16 */ FieldListList: Sep Field FieldListList; // Vec<T>::Push
/*  17 */ FieldListList: ; // Vec<T>::New
/*  18 */ Field: FieldOpt /* Option */ Identifier;
/*  19 */ FieldOpt: StorageMode; // Option<T>::Some
/*  20 */ FieldOpt: ; // Option<T>::None
/*  21 */ StorageMode: "atomic";
/*  22 */ Function: FunctionOpt /* Option */ "fn" Identifier ArgumentList FunctionBody;
/*  23 */ FunctionOpt: Effect; // Option<T>::Some
/*  24 */ FunctionOpt: ; // Option<T>::None
/*  25 */ Effect: "async";
/*  26 */ ArgumentList: "\(" ArgumentListSuffix;
/*  27 */ ArgumentListSuffix: "\)";
/*  28 */ ArgumentListSuffix: Identifier ArgumentListList /* Vec */ MaybeTrailingComma "\)";
/*  29 */ ArgumentListList: Sep Identifier ArgumentListList; // Vec<T>::Push
/*  30 */ ArgumentListList: ; // Vec<T>::New
/*  31 */ FunctionBody: BlockExpr;
/*  32 */ Expr: LocalVariable;
/*  33 */ Expr: Expr5;
/*  34 */ Expr5: Expr4 Expr5List /* Vec */;
/*  35 */ Expr5List: "(?:\+|-|/|\*|:)=" Expr4 Expr5List; // Vec<T>::Push
/*  36 */ Expr5List: ; // Vec<T>::New
/*  37 */ Expr4: Expr3 Expr4List /* Vec */;
/*  38 */ Expr4List: "==|<|>" Expr3 Expr4List; // Vec<T>::Push
/*  39 */ Expr4List: ; // Vec<T>::New
/*  40 */ Expr3: Expr2 Expr3List /* Vec */;
/*  41 */ Expr3List: "\+|-" Expr2 Expr3List; // Vec<T>::Push
/*  42 */ Expr3List: ; // Vec<T>::New
/*  43 */ Expr2: Expr1 Expr2List /* Vec */;
/*  44 */ Expr2List: "/|\*" Expr1 Expr2List; // Vec<T>::Push
/*  45 */ Expr2List: ; // Vec<T>::New
/*  46 */ Expr1: Expr0 Expr1List /* Vec */;
/*  47 */ Expr1List: Expr1ListGroup Expr1List; // Vec<T>::Push
/*  48 */ Expr1ListGroup: DotExpr;
/*  49 */ Expr1ListGroup: CallArgumentList;
/*  50 */ Expr1List: ; // Vec<T>::New
/*  51 */ DotExpr: "\." DotSuffix;
/*  52 */ DotSuffix: "await";
/*  53 */ DotSuffix: "share";
/*  54 */ DotSuffix: "give";
/*  55 */ DotSuffix: "lease";
/*  56 */ DotSuffix: Identifier;
/*  57 */ CallArgumentList: "\(" CallArgumentListSuffix;
/*  58 */ CallArgumentListSuffix: "\)";
/*  59 */ CallArgumentListSuffix: CallArgument CallArgumentListList /* Vec */ MaybeTrailingComma "\)";
/*  60 */ CallArgumentListList: Sep CallArgument CallArgumentListList; // Vec<T>::Push
/*  61 */ CallArgumentListList: ; // Vec<T>::New
/*  62 */ CallArgument: CallArgumentOpt /* Option */ Expr;
/*  63 */ CallArgumentOpt: Identifier ":"; // Option<T>::Some
/*  64 */ CallArgumentOpt: ; // Option<T>::None
/*  65 */ Expr0: Identifier;
/*  66 */ Expr0: BooleanLiteral;
/*  67 */ Expr0: FloatLiteral;
/*  68 */ Expr0: IntegerLiteral;
/*  69 */ Expr0: StringLiteral;
/*  70 */ Expr0: BlockExpr;
/*  71 */ Expr0: AtomicBlock;
/*  72 */ Expr0: IfExpr;
/*  73 */ Expr0: Loop;
/*  74 */ Expr0: While;
/*  75 */ Expr0: Tuple;
/*  76 */ BooleanLiteral: "true|false";
/*  77 */ Identifier: "[a-z|A-Z_][a-z|A-Z|0-9_]*";
/*  78 */ FloatLiteral: "[0-9][0-9_]*\.[0-9][0-9_]*";
/*  79 */ IntegerLiteral: "[0-9][0-9_]*";
/*  80 */ StringLiteral: "\u{0022}(?s:[^\u{0022}]*)\u{0022}";
/*  81 */ ReturnExpr: "return" ReturnExprOpt /* Option */;
/*  82 */ ReturnExprOpt: Expr; // Option<T>::Some
/*  83 */ ReturnExprOpt: ; // Option<T>::None
/*  84 */ BlockExpr: "\{" BlockExprList /* Vec */ BlockExprOpt /* Option */ "\}";
/*  85 */ BlockExprList: Expr BlockExprList; // Vec<T>::Push
/*  86 */ BlockExprList: ; // Vec<T>::New
/*  87 */ BlockExprOpt: ReturnExpr; // Option<T>::Some
/*  88 */ BlockExprOpt: ; // Option<T>::None
/*  89 */ AtomicBlock: "atomic" BlockExpr;
/*  90 */ IfExpr: "if" Condition BlockExpr IfExprOpt /* Option */;
/*  91 */ IfExprOpt: "else" BlockExpr; // Option<T>::Some
/*  92 */ IfExprOpt: ; // Option<T>::None
/*  93 */ Condition: Expr;
/*  94 */ Loop: "loop" BlockExpr;
/*  95 */ While: "while" Condition BlockExpr;
/*  96 */ Tuple: "tuple";
/*  97 */ LocalVariable: LocalVariableOpt /* Option */ Identifier "=" Expr;
/*  98 */ LocalVariableOpt: StorageMode; // Option<T>::Some
/*  99 */ LocalVariableOpt: ; // Option<T>::None
